<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pypeln.process API documentation</title>
    <meta name="description" content="The `process` module lets you create pipelines using objects from python's [multiprocessing](https:/..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pypeln.process.concat">concat</a></li>
    <li class="mono"><a href="#pypeln.process.each">each</a></li>
    <li class="mono"><a href="#pypeln.process.filter">filter</a></li>
    <li class="mono"><a href="#pypeln.process.flat_map">flat_map</a></li>
    <li class="mono"><a href="#pypeln.process.from_iterable">from_iterable</a></li>
    <li class="mono"><a href="#pypeln.process.map">map</a></li>
    <li class="mono"><a href="#pypeln.process.run">run</a></li>
    <li class="mono"><a href="#pypeln.process.to_iterable">to_iterable</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pypeln.process.StageStatus">StageStatus</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pypeln.process.StageStatus.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pypeln.process.WorkerInfo">WorkerInfo</a></span>
        
        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pypeln.process</span> module</h1>
  <p>The <code>process</code> module lets you create pipelines using objects from python's <a href="https://docs.python.org/3.4/library/multiprocessing.html">multiprocessing</a> module according to Pypeline's general <a href="https://cgarciae.gitbook.io/pypeln/#architecture">architecture</a>. Use this module when you are in need of true parallelism for CPU heavy operations but be aware of its implications (continue reading).</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">slow_add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">slow_gt3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># [0, 1, 2, ..., 9]</span>

<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">slow_add1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">slow_gt3</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="c1"># e.g. [5, 6, 9, 4, 8, 10, 7]</span>
</pre></div>


<h2>Stage</h2>
<p>All functions from this module return a private <code>pypeln.process._Stage</code> object. Stages are lazy, that is, a <code>_Stage</code> objects merely contains the information needed to perform the computation of itself and the Stages it depends on. Stages are <a href="https://docs.python.org/3/glossary.html#term-iterable">iterables</a> i.e. they implement <code>__iter__</code>, to actually execute the pipeline you can directly iterable them or iterate over the generator returned by <a href="#pypeln.process.to_iterable"><code>to_iterable</code></a> which gives you more control.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">slow_add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># [0, 1, 2, ..., 9]</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">slow_add1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stage</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># e.g. 2, 1, 5, 6, 3, 4, 7, 8, 9, 10</span>
</pre></div>


<p>This iterable API makes Pypeline a very intuitive/pythonic to use and compatible with most other python code. </p>
<h2>Workers</h2>
<p>The worker type of this module is a <a href="https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.Process">multiprocessing.Process</a>. Each worker process is instantiated with <code>daemon = True</code>. Creating each process is slow and consumes a lot of memory. Since processes are technically separate programs managed by the OS they are great for doing operations in parallel by avoiding the <a href="https://realpython.com/python-gil">GIL</a> (or rather having their separate GIL).</p>
<p>The number of workers on each stage can usually be controled by the <code>workers</code> parameter on <code>pypeln.process</code>'s various functions. Try not to create more processes than the number of cores you have on your machine or else they will end up fighting for resources and computation will be suboptimal.</p>
<h2>Queue</h2>
<p>The queue type of this module is a <a href="https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.Queue">multiprocessing.Queue</a>. Since processes don't share memory, all information passed between them through these queues must first be serialized (pickled) which is slow, be aware of this and try to avoid sending large objects.</p>
<p>The number of elements each stage can hold usually be controled by the <code>maxsize</code> parameter on <code>pypeln.process</code>'s various functions. When passed this parameter sets a maximum size for the input Queue of the stage, this serves as a <a href="https://www.quora.com/What-is-backpressure-in-the-context-of-data-streaming">backpressure</a> mechanism because any stages pushing data to a Queue that becomes full (reaches its <code>maxsize</code>) will have to stop their computation until space becomes available, thus, potentially preveting <code>OutOfMemeory</code> errors due to overpressure from faster stages.</p>
<h2>Resource Management</h2>
<p>There are many occasions where you need to create some resource objects (e.g. http or database sessions) that for efficiency are expected to last the whole lifespan of each worker. To handle such objects many functions have the <code>on_start</code> and <code>on_done</code> arguments which expect some callback functions. </p>
<p>When a worker is created it calls the <code>on_start</code> function, this functions should create and return the resource objects. These object will be passed as extra arguments to the main function and also to the <code>on_end</code> function.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="k">def</span> <span class="nf">x</span><span class="p">():</span>
    <span class="n">http_session</span> <span class="o">=</span> <span class="n">get_http_session</span><span class="p">()</span>
    <span class="n">db_session</span> <span class="o">=</span> <span class="n">get_db_session</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">http_session</span><span class="p">,</span> <span class="n">db_session</span>

<span class="k">def</span> <span class="nf">on_end</span><span class="p">(</span><span class="n">_stage_status</span><span class="p">,</span> <span class="n">http_session</span><span class="p">,</span> <span class="n">db_session</span><span class="p">):</span>
    <span class="n">http_session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">db_session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">http_session</span><span class="p">,</span> <span class="n">db_session</span><span class="p">):</span>
    <span class="c1"># some logic</span>
    <span class="k">return</span> <span class="n">y</span>

<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">)</span>
</pre></div>


<p>A few notes:</p>
<ul>
<li>The resource objects are created per worker.</li>
<li><code>on_start</code> should return a object other that <code>None</code> or a tuple of resource objects.</li>
<li>If <code>on_start</code> returns some arguments then they must be accepted by <code>f</code> and <code>on_end</code>.</li>
<li><code>on_end</code> receives a <a href="#pypeln.process.StageStatus"><code>StageStatus</code></a> object followed by the resource objects created by <code>on_start</code>.</li>
</ul>
<h2>Pipe Operator</h2>
<p>Functions that accept a <code>stage</code> parameter return a <code>Partial</code> instead of a new stage when <code>stage</code> is not given. These <code>Partial</code>s are callables that accept the missing <code>stage</code> parameter and return the full output of the original function. For example</p>
<div class="codehilite"><pre><span></span>pr.map(f, stage, **kwargs) = pr.map(f, **kwargs)(stage)
</pre></div>


<p>The important thing about partials is that they implement the pipe <code>|</code> operator as</p>
<div class="codehilite"><pre><span></span>x | partial = partial(x)
</pre></div>


<p>This allows you to define pipelines in the following way:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypenl</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">slow_add1</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">pr</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">slow_gt3</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">|</span> <span class="nb">list</span>
<span class="p">)</span>
</pre></div>


<h2>Recomendations</h2>
<p>Creating processes and doing Inter-Process Communication (IPC) is expensive, therefore we recommend the following:</p>
<ul>
<li>Minimize the number of stages based on this module.</li>
<li>Tune the number of workers based on the number of cores.</li>
<li>When processing large datasets set the maxsize of the stage to prevent <code>OutOfMemory</code> errors.</li>
<li>If possible don't send large objects.</li>
<li>If you just need a single stage to perform a task over a collection in parallel use the <a href="#pypeln.process.each"><code>each</code></a> function.</li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot; The `process` module lets you create pipelines using objects from python&#39;s [multiprocessing](https://docs.python.org/3.4/library/multiprocessing.html) module according to Pypeline&#39;s general [architecture](https://cgarciae.gitbook.io/pypeln/#architecture). Use this module when you are in need of true parallelism for CPU heavy operations but be aware of its implications (continue reading).</span>

<span class="sd">    from pypeln import process as pr</span>
<span class="sd">    import time</span>
<span class="sd">    from random import random</span>

<span class="sd">    def slow_add1(x):</span>
<span class="sd">        time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">        return x + 1</span>

<span class="sd">    def slow_gt3(x):</span>
<span class="sd">        time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">        return x &gt; 3</span>

<span class="sd">    data = range(10) # [0, 1, 2, ..., 9] </span>

<span class="sd">    stage = pr.map(slow_add1, data, workers = 3, maxsize = 4)</span>
<span class="sd">    stage = pr.filter(slow_gt3, stage, workers = 2)</span>

<span class="sd">    data = list(stage) # e.g. [5, 6, 9, 4, 8, 10, 7]</span>

<span class="sd">## Stage</span>
<span class="sd">All functions from this module return a private `pypeln.process._Stage` object. Stages are lazy, that is, a `_Stage` objects merely contains the information needed to perform the computation of itself and the Stages it depends on. Stages are [iterables](https://docs.python.org/3/glossary.html#term-iterable) i.e. they implement `__iter__`, to actually execute the pipeline you can directly iterable them or iterate over the generator returned by `pypeln.process.to_iterable` which gives you more control.</span>

<span class="sd">    from pypeln import process as pr</span>
<span class="sd">    import time</span>
<span class="sd">    from random import random</span>

<span class="sd">    def slow_add1(x):</span>
<span class="sd">        time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">        return x + 1</span>

<span class="sd">    data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">    stage = pr.map(slow_add1, data, workers = 3, maxsize = 4)</span>

<span class="sd">    for x in stage:</span>
<span class="sd">        print(x) # e.g. 2, 1, 5, 6, 3, 4, 7, 8, 9, 10</span>

<span class="sd">This iterable API makes Pypeline a very intuitive/pythonic to use and compatible with most other python code. </span>

<span class="sd">## Workers</span>
<span class="sd">The worker type of this module is a [multiprocessing.Process](https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.Process). Each worker process is instantiated with `daemon = True`. Creating each process is slow and consumes a lot of memory. Since processes are technically separate programs managed by the OS they are great for doing operations in parallel by avoiding the [GIL](https://realpython.com/python-gil) (or rather having their separate GIL).</span>

<span class="sd">The number of workers on each stage can usually be controled by the `workers` parameter on `pypeln.process`&#39;s various functions. Try not to create more processes than the number of cores you have on your machine or else they will end up fighting for resources and computation will be suboptimal.</span>

<span class="sd">## Queue</span>
<span class="sd">The queue type of this module is a [multiprocessing.Queue](https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.Queue). Since processes don&#39;t share memory, all information passed between them through these queues must first be serialized (pickled) which is slow, be aware of this and try to avoid sending large objects.</span>

<span class="sd">The number of elements each stage can hold usually be controled by the `maxsize` parameter on `pypeln.process`&#39;s various functions. When passed this parameter sets a maximum size for the input Queue of the stage, this serves as a [backpressure](https://www.quora.com/What-is-backpressure-in-the-context-of-data-streaming) mechanism because any stages pushing data to a Queue that becomes full (reaches its `maxsize`) will have to stop their computation until space becomes available, thus, potentially preveting `OutOfMemeory` errors due to overpressure from faster stages.</span>

<span class="sd">## Resource Management</span>
<span class="sd">There are many occasions where you need to create some resource objects (e.g. http or database sessions) that for efficiency are expected to last the whole lifespan of each worker. To handle such objects many functions have the `on_start` and `on_done` arguments which expect some callback functions. </span>

<span class="sd">When a worker is created it calls the `on_start` function, this functions should create and return the resource objects. These object will be passed as extra arguments to the main function and also to the `on_end` function.</span>

<span class="sd">    from pypeln import process as pr</span>

<span class="sd">    def x():</span>
<span class="sd">        http_session = get_http_session()</span>
<span class="sd">        db_session = get_db_session()</span>
<span class="sd">        return http_session, db_session</span>

<span class="sd">    def on_end(_stage_status, http_session, db_session):</span>
<span class="sd">        http_session.close()</span>
<span class="sd">        db_session.close()</span>

<span class="sd">    def f(x, http_session, db_session):</span>
<span class="sd">        # some logic</span>
<span class="sd">        return y</span>

<span class="sd">    stage = pr.map(f, stage, workers = 3, on_start = on_start)</span>

<span class="sd">A few notes:</span>

<span class="sd">* The resource objects are created per worker.</span>
<span class="sd">* `on_start` should return a object other that `None` or a tuple of resource objects.</span>
<span class="sd">* If `on_start` returns some arguments then they must be accepted by `f` and `on_end`.</span>
<span class="sd">* `on_end` receives a `pypeln.process.StageStatus` object followed by the resource objects created by `on_start`.</span>

<span class="sd">## Pipe Operator</span>
<span class="sd">Functions that accept a `stage` parameter return a `Partial` instead of a new stage when `stage` is not given. These `Partial`s are callables that accept the missing `stage` parameter and return the full output of the original function. For example</span>

<span class="sd">    pr.map(f, stage, **kwargs) = pr.map(f, **kwargs)(stage)</span>

<span class="sd">The important thing about partials is that they implement the pipe `|` operator as</span>

<span class="sd">    x | partial = partial(x)</span>

<span class="sd">This allows you to define pipelines in the following way:</span>

<span class="sd">    from pypenl import process as pr</span>

<span class="sd">    data = (</span>
<span class="sd">        range(10)</span>
<span class="sd">        | pr.map(slow_add1, workers = 3, maxsize = 4)</span>
<span class="sd">        | pr.filter(slow_gt3, workers = 2)</span>
<span class="sd">        | list</span>
<span class="sd">    )</span>

<span class="sd">## Recomendations</span>
<span class="sd">Creating processes and doing Inter-Process Communication (IPC) is expensive, therefore we recommend the following:</span>

<span class="sd">* Minimize the number of stages based on this module.</span>
<span class="sd">* Tune the number of workers based on the number of cores.</span>
<span class="sd">* When processing large datasets set the maxsize of the stage to prevent `OutOfMemory` errors.</span>
<span class="sd">* If possible don&#39;t send large objects.</span>
<span class="sd">* If you just need a single stage to perform a task over a collection in parallel use the `pypeln.process.each` function. </span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c1">#############</span>
<span class="c1"># imports pr</span>
<span class="c1">#############</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span> <span class="k">as</span> <span class="n">WORKER</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">multiprocessing.queues</span> <span class="kn">import</span> <span class="n">Full</span><span class="p">,</span> <span class="n">Empty</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="n">_MANAGER</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">get_namespace</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">_MANAGER</span><span class="o">.</span><span class="n">Namespace</span><span class="p">()</span>

<span class="c1">#############</span>
<span class="c1"># imports th</span>
<span class="c1">#############</span>

<span class="c1"># from threading import Thread as WORKER</span>
<span class="c1"># from threading import Thread</span>
<span class="c1"># from.utils import Namespace</span>
<span class="c1"># from six.moves.queue import Queue, Empty, Full</span>
<span class="c1"># from threading import Lock</span>

<span class="c1"># def get_namespace():</span>
<span class="c1">#     return Namespace()</span>


<span class="c1">####################</span>
<span class="c1"># classes</span>
<span class="c1">####################</span>

<span class="k">class</span> <span class="nc">_Stage</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">BaseStage</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_constructor</span><span class="p">,</span> <span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">dependencies</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">worker_constructor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">dependencies</span>
    
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;_Stage(worker_constructor = {worker_constructor}, workers = {workers}, maxsize = {maxsize}, target = {target}, args = {args}, dependencies = {dependencies})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">worker_constructor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">worker_constructor</span><span class="p">,</span>
            <span class="n">workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">,</span>
            <span class="n">maxsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
            <span class="n">dependencies</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">),</span>
        <span class="p">)</span>

<span class="k">class</span> <span class="nc">_StageParams</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;_StageParams&quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="s2">&quot;input_queue&quot;</span><span class="p">,</span> <span class="s2">&quot;output_queues&quot;</span><span class="p">,</span> <span class="s2">&quot;on_start&quot;</span><span class="p">,</span> <span class="s2">&quot;on_done&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;stage_namespace&quot;</span><span class="p">,</span> <span class="s2">&quot;stage_lock&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pipeline_namespace&quot;</span><span class="p">,</span> <span class="s2">&quot;pipeline_error_queue&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index&quot;</span><span class="p">,</span>
    <span class="p">])):</span>
    <span class="k">pass</span>

<span class="n">WorkerInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;WorkerInfo&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">StageStatus</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object passed to various `on_done` callbacks. It contains information about the stage in case book keeping is needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">lock</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `bool` : `True` if all workers finished. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span><span class="o">.</span><span class="n">active_workers</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `int` : Number of active workers. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span><span class="o">.</span><span class="n">active_workers</span>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;StageStatus(done = {done}, active_workers = {active_workers})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">,</span>
            <span class="n">active_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_workers</span><span class="p">,</span>
        <span class="p">)</span>

<span class="k">class</span> <span class="nc">_InputQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">total_done</span><span class="p">,</span> <span class="n">pipeline_namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">get_namespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="n">total_done</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_namespace</span> <span class="o">=</span> <span class="n">pipeline_namespace</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_namespace</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_continue</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">TIMEOUT</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">Empty</span><span class="p">,</span> <span class="n">Full</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">CONTINUE</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_done</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
            
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">CONTINUE</span>

    <span class="k">def</span> <span class="nf">is_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">DONE</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_OutputQueues</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">DONE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_handle_exceptions</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle_exceptions</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>

        <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">pipeline_error_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()))))</span>
                <span class="n">params</span><span class="o">.</span><span class="n">pipeline_namespace</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">handle_exceptions</span>


<span class="k">def</span> <span class="nf">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">on_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">on_start</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">on_start</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">n_args</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">worker_info</span> <span class="o">=</span> <span class="n">WorkerInfo</span><span class="p">(</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span>
                <span class="p">)</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">on_start</span><span class="p">(</span><span class="n">worker_info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">None</span>


        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
        
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">input_queue</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">input_queue</span><span class="p">:</span>
                <span class="n">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f_task</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">on_done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">params</span><span class="o">.</span><span class="n">stage_lock</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">stage_namespace</span><span class="o">.</span><span class="n">active_workers</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">stage_status</span> <span class="o">=</span> <span class="n">StageStatus</span><span class="p">(</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">stage_namespace</span><span class="p">,</span>
                <span class="n">lock</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">stage_lock</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">params</span><span class="o">.</span><span class="n">on_done</span><span class="p">(</span><span class="n">stage_status</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">pipeline_error_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()))))</span>
            <span class="n">params</span><span class="o">.</span><span class="n">pipeline_namespace</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    

<span class="c1">###########</span>
<span class="c1"># map</span>
<span class="c1">###########</span>


<span class="k">def</span> <span class="nf">_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="nd">@_handle_exceptions</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that maps a function `f` over the data. Its intended to behave like python&#39;s built-in `map` function but with the added concurrency.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_add1(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">            return x + 1</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.map(slow_add1, data, workers = 3, maxsize = 4)</span>

<span class="sd">        data = list(stage) # e.g. [2, 1, 5, 6, 3, 4, 7, 8, 9, 10]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; y`, where `args` is the return of `on_start` if present, else the signature is just `f(x) -&gt; y`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_map</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>

<span class="c1">###########</span>
<span class="c1"># flat_map</span>
<span class="c1">###########</span>

<span class="k">def</span> <span class="nf">_flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="nd">@_handle_exceptions</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that maps a function `f` over the data, however unlike `pypeln.process.map` in this case `f` returns an iterable. As its name implies, `flat_map` will flatten out these iterables so the resulting stage just contains their elements.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_integer_pair(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>

<span class="sd">            if x == 0:</span>
<span class="sd">                yield x</span>
<span class="sd">            else:</span>
<span class="sd">                yield x</span>
<span class="sd">                yield -x</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.flat_map(slow_integer_pair, data, workers = 3, maxsize = 4)</span>

<span class="sd">        list(stage) # e.g. [2, -2, 3, -3, 0, 1, -1, 6, -6, 4, -4, ...]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed. Also, `flat_map` is more general than both `pypeln.process.map` and `pypeln.process.filter`, as such these expressions are equivalent:</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        pr.map(f, stage) = pr.flat_map(lambda x: [f(x)], stage)</span>
<span class="sd">        pr.filter(f, stage) = pr.flat_map(lambda x: [x] if f(x) else [], stage)</span>

<span class="sd">    Using `flat_map` with a generator function is very useful as we are able to filter out unwanted elements when e.g. there are exceptions, missing data, etc.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; [y]`, where `args` is the return of `on_start` if present, else the signature is just `f(x) -&gt; [y]`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_flat_map</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>


<span class="c1">###########</span>
<span class="c1"># filter</span>
<span class="c1">###########</span>

<span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="nd">@_handle_exceptions</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that filter the data given a predicate function `f`. It is intended to behave like python&#39;s built-in `filter` function but with the added concurrency.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_gt3(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">            return x &gt; 3</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.filter(slow_gt3, data, workers = 3, maxsize = 4)</span>

<span class="sd">        data = list(stage) # e.g. [5, 6, 3, 4, 7, 8, 9]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; bool`, where `args` is the return of `on_start` if present, else the signature is just `f(x)`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_filter</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>


<span class="c1">###########</span>
<span class="c1"># each</span>
<span class="c1">###########</span>

<span class="k">def</span> <span class="nf">_each</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="nd">@_handle_exceptions</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">each</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">run</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that runs the function `f` for each element in the data but the stage itself yields no elements. Its useful for sink stages that perform certain actions such as writting to disk, saving to a database, etc, and dont produce any results. For example:</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        def process_image(image_path):</span>
<span class="sd">            image = load_image(image_path)</span>
<span class="sd">            image = transform_image(image)</span>
<span class="sd">            save_image(image_path, image)</span>

<span class="sd">        files_paths = get_file_paths()</span>
<span class="sd">        stage = pr.each(process_image, file_paths, workers = 4)</span>
<span class="sd">        pr.run(stage)</span>

<span class="sd">    or alternatively</span>

<span class="sd">        files_paths = get_file_paths()</span>
<span class="sd">        pr.each(process_image, file_paths, workers = 4, run = True)</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; None`, where `args` is the return of `on_start` if present, else the signature is just `f(x)`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>
<span class="sd">    * **`run = False`** : specify whether to run the stage immediately.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is not given then this function returns a `Partial`, else if `return = False` (default) it return a new stage, if `run = True` then it runs the stage and returns `None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">each</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_each</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">run</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stage</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">stage</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="c1">###########</span>
<span class="c1"># concat</span>
<span class="c1">###########</span>

<span class="k">def</span> <span class="nf">_concat</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenates / merges many stages into a single one by appending elements from each stage as they come, order is not preserved.</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        stage_1 = [1, 2, 3]</span>
<span class="sd">        stage_2 = [4, 5, 6, 7]</span>

<span class="sd">        stage_3 = pr.concat([stage_1, stage_2]) # e.g. [1, 4, 5, 2, 6, 3, 7]</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stages`** : a list of stages or iterables.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * A stage object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stages</span> <span class="p">]</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_concat</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="n">stages</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c1">################</span>
<span class="c1"># run</span>
<span class="c1">################</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterates over one or more stages until their iterators run out of elements.</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        data = get_data()</span>
<span class="sd">        stage = pr.each(slow_fn, data, workers = 6)</span>

<span class="sd">        # execute pipeline</span>
<span class="sd">        pr.run(stage)</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stages`** : a stage/iterable or list of stages/iterables to be iterated over. If a list is passed, stages are first merged using `pypeln.process.concat` before iterating.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * `None`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected at least 1 stage to run&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">stages</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">:</span>
        <span class="k">pass</span>

    

<span class="c1">################</span>
<span class="c1"># _to_stage</span>
<span class="c1">################ </span>

<span class="k">def</span> <span class="nf">_to_stage</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_Stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">from_iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Object {obj} is not iterable&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">))</span>

<span class="c1">################</span>
<span class="c1"># from_iterable</span>
<span class="c1">################</span>

<span class="k">def</span> <span class="nf">_from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">f_task</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">output_queues</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">_run_task</span><span class="p">(</span><span class="n">f_task</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    
    

<span class="k">def</span> <span class="nf">from_iterable</span><span class="p">(</span><span class="n">iterable</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage from an iterable. This function gives you more control of how a stage is created through the `worker_constructor` parameter which can be either:</span>
<span class="sd">    </span>
<span class="sd">    * `threading.Thread`: (default) is efficient for iterables that already have the data in memory like lists or numpy arrays because threads can share memory so no serialization is needed. </span>
<span class="sd">    * `multiprocessing.Process`: is efficient for iterables who&#39;s data is not in memory like arbitrary generators and benefit from escaping the GIL. This is inefficient for iterables which have data in memory because they have to be serialized when sent to the background process.</span>

<span class="sd">    All functions that accept stages or iterables use this function when an iterable is passed to convert it into a stage using the default arguments.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`iterable`** : a source iterable.</span>
<span class="sd">    * **`maxsize = None`** : this parameter is not used and only kept for API compatibility with the other modules.</span>
<span class="sd">    * **`worker_constructor = threading.Thread`** : defines the worker type for the producer stage.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `iterable` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">iterable</span><span class="p">:</span> <span class="n">from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">worker_constructor</span><span class="o">=</span><span class="n">worker_constructor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">worker_constructor</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_from_iterable</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="p">)</span>

<span class="c1">##############</span>
<span class="c1"># to_iterable</span>
<span class="c1">##############</span>

<span class="k">def</span> <span class="nf">_build_queues</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">stage_input_queue</span><span class="p">,</span> <span class="n">stage_output_queues</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">pipeline_namespace</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stage_input_queue</span><span class="p">,</span> <span class="n">stage_output_queues</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">dependencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_done</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">s</span><span class="o">.</span><span class="n">workers</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">dependencies</span> <span class="p">])</span>
        <span class="n">input_queue</span> <span class="o">=</span> <span class="n">_InputQueue</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">total_done</span><span class="p">,</span> <span class="n">pipeline_namespace</span><span class="p">)</span>
        <span class="n">stage_input_queue</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_queue</span>

        <span class="k">for</span> <span class="n">_stage</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">_stage</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stage_output_queues</span><span class="p">:</span>
                <span class="n">stage_output_queues</span><span class="p">[</span><span class="n">_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">_OutputQueues</span><span class="p">([</span><span class="n">input_queue</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stage_output_queues</span><span class="p">[</span><span class="n">_stage</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_queue</span><span class="p">)</span>

            <span class="n">stage_input_queue</span><span class="p">,</span> <span class="n">stage_output_queues</span> <span class="o">=</span> <span class="n">_build_queues</span><span class="p">(</span>
                <span class="n">_stage</span><span class="p">,</span>
                <span class="n">stage_input_queue</span><span class="p">,</span>
                <span class="n">stage_output_queues</span><span class="p">,</span>
                <span class="n">visited</span><span class="p">,</span>
                <span class="n">pipeline_namespace</span> <span class="o">=</span> <span class="n">pipeline_namespace</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">stage_input_queue</span><span class="p">,</span> <span class="n">stage_output_queues</span>

<span class="k">def</span> <span class="nf">_create_worker</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">output_queues</span><span class="p">,</span> <span class="n">input_queue</span><span class="p">):</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">output_queues</span> <span class="o">=</span> <span class="n">output_queues</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">input_queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">input_queue</span> <span class="o">=</span> <span class="n">input_queue</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">WORKER</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">):</span>

    <span class="n">pipeline_namespace</span> <span class="o">=</span> <span class="n">get_namespace</span><span class="p">()</span>
    <span class="n">pipeline_namespace</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">pipeline_error_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    


    <span class="n">input_queue</span> <span class="o">=</span> <span class="n">_InputQueue</span><span class="p">(</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">workers</span><span class="p">,</span> <span class="n">pipeline_namespace</span><span class="p">)</span>

    <span class="n">stage_input_queue</span><span class="p">,</span> <span class="n">stage_output_queues</span> <span class="o">=</span> <span class="n">_build_queues</span><span class="p">(</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">stage</span><span class="p">,</span>
        <span class="n">stage_input_queue</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
        <span class="n">stage_output_queues</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span>
        <span class="n">pipeline_namespace</span> <span class="o">=</span> <span class="n">pipeline_namespace</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">stage_output_queues</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">_OutputQueues</span><span class="p">([</span> <span class="n">input_queue</span> <span class="p">])</span>
    
    <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_stage</span> <span class="ow">in</span> <span class="n">stage_output_queues</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">_stage</span><span class="o">.</span><span class="n">on_done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stage_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
            <span class="n">stage_namespace</span> <span class="o">=</span> <span class="n">get_namespace</span><span class="p">()</span>
            <span class="n">stage_namespace</span><span class="o">.</span><span class="n">active_workers</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">workers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stage_lock</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">stage_namespace</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_stage</span><span class="o">.</span><span class="n">workers</span><span class="p">):</span>

            <span class="n">stage_params</span> <span class="o">=</span> <span class="n">_StageParams</span><span class="p">(</span>
                <span class="n">output_queues</span> <span class="o">=</span> <span class="n">stage_output_queues</span><span class="p">[</span><span class="n">_stage</span><span class="p">],</span>
                <span class="n">input_queue</span> <span class="o">=</span> <span class="n">stage_input_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_stage</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                <span class="n">on_start</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">on_start</span><span class="p">,</span>
                <span class="n">on_done</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">on_done</span><span class="p">,</span>
                <span class="n">stage_lock</span> <span class="o">=</span> <span class="n">stage_lock</span><span class="p">,</span>
                <span class="n">stage_namespace</span> <span class="o">=</span> <span class="n">stage_namespace</span><span class="p">,</span>
                <span class="n">pipeline_namespace</span> <span class="o">=</span> <span class="n">pipeline_namespace</span><span class="p">,</span>
                <span class="n">pipeline_error_queue</span> <span class="o">=</span> <span class="n">pipeline_error_queue</span><span class="p">,</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">worker_constructor</span><span class="p">(</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">_stage</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">stage_params</span><span class="p">,)</span>
            <span class="p">)</span>

            <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_queue</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">pipeline_namespace</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="n">error_class</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">pipeline_error_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">error_class</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Original {trace}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="p">))</span>

        
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">stage_input_queue</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">q</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
        
        <span class="k">raise</span>

<span class="k">def</span> <span class="nf">to_iterable</span><span class="p">(</span><span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an iterable from a stage. This function is used by the stage&#39;s `__iter__` method with the default arguments.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stage`** : a stage object.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns an iterable, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">_to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>

    

    
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pypeln.process.concat">
    <p>def <span class="ident">concat</span>(</p><p>stages, maxsize=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Concatenates / merges many stages into a single one by appending elements from each stage as they come, order is not preserved.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="n">stage_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">stage_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>

<span class="n">stage_3</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">stage_1</span><span class="p">,</span> <span class="n">stage_2</span><span class="p">])</span> <span class="c1"># e.g. [1, 4, 5, 2, 6, 3, 7]</span>
</pre></div>


<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>stages</code></strong> : a list of stages or iterables.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>A stage object.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.concat', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.concat" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenates / merges many stages into a single one by appending elements from each stage as they come, order is not preserved.</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        stage_1 = [1, 2, 3]</span>
<span class="sd">        stage_2 = [4, 5, 6, 7]</span>

<span class="sd">        stage_3 = pr.concat([stage_1, stage_2]) # e.g. [1, 4, 5, 2, 6, 3, 7]</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stages`** : a list of stages or iterables.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * A stage object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stages</span> <span class="p">]</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_concat</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="n">stages</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.each">
    <p>def <span class="ident">each</span>(</p><p>f, stage=Undefined, workers=1, maxsize=0, on_start=None, on_done=None, run=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a stage that runs the function <code>f</code> for each element in the data but the stage itself yields no elements. Its useful for sink stages that perform certain actions such as writting to disk, saving to a database, etc, and dont produce any results. For example:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="k">def</span> <span class="nf">process_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">transform_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">save_image</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

<span class="n">files_paths</span> <span class="o">=</span> <span class="n">get_file_paths</span><span class="p">()</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">process_image</span><span class="p">,</span> <span class="n">file_paths</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">pr</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
</pre></div>


<p>or alternatively</p>
<div class="codehilite"><pre><span></span>files_paths = get_file_paths()
pr.each(process_image, file_paths, workers = 4, run = True)
</pre></div>


<p>Note that because of concurrency order is not guaranteed.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>f</code></strong> : a function with signature <code>f(x, *args) -&gt; None</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>f(x)</code>. </li>
<li><strong><code>stage = Undefined</code></strong> : a stage or iterable.</li>
<li><strong><code>workers = 1</code></strong> : the number of workers the stage should contain.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
<li><strong><code>on_start = None</code></strong> : a function with signature <code>on_start() -&gt; args</code>, where <code>args</code> can be any object different than <code>None</code> or a tuple of objects. The returned <code>args</code> are passed to <code>f</code> and <code>on_done</code>. This function is executed once per worker at the beggining.</li>
<li><strong><code>on_done = None</code></strong> : a function with signature <code>on_done(stage_status, *args)</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>on_done(stage_status)</code>, and <code>stage_status</code> is of type <a href="#pypeln.process.StageStatus"><code>StageStatus</code></a>. This function is executed once per worker when the worker is done.</li>
<li><strong><code>run = False</code></strong> : specify whether to run the stage immediately.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>stage</code> parameters is not given then this function returns a <code>Partial</code>, else if <code>return = False</code> (default) it return a new stage, if <code>run = True</code> then it runs the stage and returns <code>None</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.each', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.each" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">each</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">run</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that runs the function `f` for each element in the data but the stage itself yields no elements. Its useful for sink stages that perform certain actions such as writting to disk, saving to a database, etc, and dont produce any results. For example:</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        def process_image(image_path):</span>
<span class="sd">            image = load_image(image_path)</span>
<span class="sd">            image = transform_image(image)</span>
<span class="sd">            save_image(image_path, image)</span>

<span class="sd">        files_paths = get_file_paths()</span>
<span class="sd">        stage = pr.each(process_image, file_paths, workers = 4)</span>
<span class="sd">        pr.run(stage)</span>

<span class="sd">    or alternatively</span>

<span class="sd">        files_paths = get_file_paths()</span>
<span class="sd">        pr.each(process_image, file_paths, workers = 4, run = True)</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; None`, where `args` is the return of `on_start` if present, else the signature is just `f(x)`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>
<span class="sd">    * **`run = False`** : specify whether to run the stage immediately.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is not given then this function returns a `Partial`, else if `return = False` (default) it return a new stage, if `run = True` then it runs the stage and returns `None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">each</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_each</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">run</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stage</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">stage</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.filter">
    <p>def <span class="ident">filter</span>(</p><p>f, stage=Undefined, workers=1, maxsize=0, on_start=None, on_done=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a stage that filter the data given a predicate function <code>f</code>. It is intended to behave like python's built-in <code>filter</code> function but with the added concurrency.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">slow_gt3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># [0, 1, 2, ..., 9]</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">slow_gt3</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="c1"># e.g. [5, 6, 3, 4, 7, 8, 9]</span>
</pre></div>


<p>Note that because of concurrency order is not guaranteed.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>f</code></strong> : a function with signature <code>f(x, *args) -&gt; bool</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>f(x)</code>. </li>
<li><strong><code>stage = Undefined</code></strong> : a stage or iterable.</li>
<li><strong><code>workers = 1</code></strong> : the number of workers the stage should contain.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
<li><strong><code>on_start = None</code></strong> : a function with signature <code>on_start() -&gt; args</code>, where <code>args</code> can be any object different than <code>None</code> or a tuple of objects. The returned <code>args</code> are passed to <code>f</code> and <code>on_done</code>. This function is executed once per worker at the beggining.</li>
<li><strong><code>on_done = None</code></strong> : a function with signature <code>on_done(stage_status, *args)</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>on_done(stage_status)</code>, and <code>stage_status</code> is of type <a href="#pypeln.process.StageStatus"><code>StageStatus</code></a>. This function is executed once per worker when the worker is done.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>stage</code> parameters is given then this function returns a new stage, else it returns a <code>Partial</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.filter', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.filter" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that filter the data given a predicate function `f`. It is intended to behave like python&#39;s built-in `filter` function but with the added concurrency.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_gt3(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">            return x &gt; 3</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.filter(slow_gt3, data, workers = 3, maxsize = 4)</span>

<span class="sd">        data = list(stage) # e.g. [5, 6, 3, 4, 7, 8, 9]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; bool`, where `args` is the return of `on_start` if present, else the signature is just `f(x)`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_filter</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.flat_map">
    <p>def <span class="ident">flat_map</span>(</p><p>f, stage=Undefined, workers=1, maxsize=0, on_start=None, on_done=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a stage that maps a function <code>f</code> over the data, however unlike <a href="#pypeln.process.map"><code>map</code></a> in this case <code>f</code> returns an iterable. As its name implies, <code>flat_map</code> will flatten out these iterables so the resulting stage just contains their elements.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">slow_integer_pair</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="o">-</span><span class="n">x</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># [0, 1, 2, ..., 9]</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="n">slow_integer_pair</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">list</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="c1"># e.g. [2, -2, 3, -3, 0, 1, -1, 6, -6, 4, -4, ...]</span>
</pre></div>


<p>Note that because of concurrency order is not guaranteed. Also, <code>flat_map</code> is more general than both <a href="#pypeln.process.map"><code>map</code></a> and <a href="#pypeln.process.filter"><code>filter</code></a>, as such these expressions are equivalent:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">)</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">stage</span><span class="p">)</span>
<span class="n">pr</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">)</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">[],</span> <span class="n">stage</span><span class="p">)</span>
</pre></div>


<p>Using <code>flat_map</code> with a generator function is very useful as we are able to filter out unwanted elements when e.g. there are exceptions, missing data, etc.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>f</code></strong> : a function with signature <code>f(x, *args) -&gt; [y]</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>f(x) -&gt; [y]</code>. </li>
<li><strong><code>stage = Undefined</code></strong> : a stage or iterable.</li>
<li><strong><code>workers = 1</code></strong> : the number of workers the stage should contain.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
<li><strong><code>on_start = None</code></strong> : a function with signature <code>on_start() -&gt; args</code>, where <code>args</code> can be any object different than <code>None</code> or a tuple of objects. The returned <code>args</code> are passed to <code>f</code> and <code>on_done</code>. This function is executed once per worker at the beggining.</li>
<li><strong><code>on_done = None</code></strong> : a function with signature <code>on_done(stage_status, *args)</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>on_done(stage_status)</code>, and <code>stage_status</code> is of type <a href="#pypeln.process.StageStatus"><code>StageStatus</code></a>. This function is executed once per worker when the worker is done.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>stage</code> parameters is given then this function returns a new stage, else it returns a <code>Partial</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.flat_map', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.flat_map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that maps a function `f` over the data, however unlike `pypeln.process.map` in this case `f` returns an iterable. As its name implies, `flat_map` will flatten out these iterables so the resulting stage just contains their elements.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_integer_pair(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>

<span class="sd">            if x == 0:</span>
<span class="sd">                yield x</span>
<span class="sd">            else:</span>
<span class="sd">                yield x</span>
<span class="sd">                yield -x</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.flat_map(slow_integer_pair, data, workers = 3, maxsize = 4)</span>

<span class="sd">        list(stage) # e.g. [2, -2, 3, -3, 0, 1, -1, 6, -6, 4, -4, ...]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed. Also, `flat_map` is more general than both `pypeln.process.map` and `pypeln.process.filter`, as such these expressions are equivalent:</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        pr.map(f, stage) = pr.flat_map(lambda x: [f(x)], stage)</span>
<span class="sd">        pr.filter(f, stage) = pr.flat_map(lambda x: [x] if f(x) else [], stage)</span>

<span class="sd">    Using `flat_map` with a generator function is very useful as we are able to filter out unwanted elements when e.g. there are exceptions, missing data, etc.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; [y]`, where `args` is the return of `on_start` if present, else the signature is just `f(x) -&gt; [y]`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_flat_map</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.from_iterable">
    <p>def <span class="ident">from_iterable</span>(</p><p>iterable=Undefined, maxsize=None, worker_constructor=&lt;class &#39;threading.Thread&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a stage from an iterable. This function gives you more control of how a stage is created through the <code>worker_constructor</code> parameter which can be either:</p>
<ul>
<li><code>threading.Thread</code>: (default) is efficient for iterables that already have the data in memory like lists or numpy arrays because threads can share memory so no serialization is needed. </li>
<li><code>multiprocessing.Process</code>: is efficient for iterables who's data is not in memory like arbitrary generators and benefit from escaping the GIL. This is inefficient for iterables which have data in memory because they have to be serialized when sent to the background process.</li>
</ul>
<p>All functions that accept stages or iterables use this function when an iterable is passed to convert it into a stage using the default arguments.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>iterable</code></strong> : a source iterable.</li>
<li><strong><code>maxsize = None</code></strong> : this parameter is not used and only kept for API compatibility with the other modules.</li>
<li><strong><code>worker_constructor = threading.Thread</code></strong> : defines the worker type for the producer stage.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>iterable</code> parameters is given then this function returns a new stage, else it returns a <code>Partial</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.from_iterable', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.from_iterable" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">from_iterable</span><span class="p">(</span><span class="n">iterable</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage from an iterable. This function gives you more control of how a stage is created through the `worker_constructor` parameter which can be either:</span>
<span class="sd">    </span>
<span class="sd">    * `threading.Thread`: (default) is efficient for iterables that already have the data in memory like lists or numpy arrays because threads can share memory so no serialization is needed. </span>
<span class="sd">    * `multiprocessing.Process`: is efficient for iterables who&#39;s data is not in memory like arbitrary generators and benefit from escaping the GIL. This is inefficient for iterables which have data in memory because they have to be serialized when sent to the background process.</span>

<span class="sd">    All functions that accept stages or iterables use this function when an iterable is passed to convert it into a stage using the default arguments.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`iterable`** : a source iterable.</span>
<span class="sd">    * **`maxsize = None`** : this parameter is not used and only kept for API compatibility with the other modules.</span>
<span class="sd">    * **`worker_constructor = threading.Thread`** : defines the worker type for the producer stage.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `iterable` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">iterable</span><span class="p">:</span> <span class="n">from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">worker_constructor</span><span class="o">=</span><span class="n">worker_constructor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">worker_constructor</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_from_iterable</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.map">
    <p>def <span class="ident">map</span>(</p><p>f, stage=Undefined, workers=1, maxsize=0, on_start=None, on_done=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a stage that maps a function <code>f</code> over the data. Its intended to behave like python's built-in <code>map</code> function but with the added concurrency.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">slow_add1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">())</span> <span class="c1"># &lt;= some slow computation</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># [0, 1, 2, ..., 9]</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">slow_add1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="c1"># e.g. [2, 1, 5, 6, 3, 4, 7, 8, 9, 10]</span>
</pre></div>


<p>Note that because of concurrency order is not guaranteed.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>f</code></strong> : a function with signature <code>f(x, *args) -&gt; y</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>f(x) -&gt; y</code>. </li>
<li><strong><code>stage = Undefined</code></strong> : a stage or iterable.</li>
<li><strong><code>workers = 1</code></strong> : the number of workers the stage should contain.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
<li><strong><code>on_start = None</code></strong> : a function with signature <code>on_start() -&gt; args</code>, where <code>args</code> can be any object different than <code>None</code> or a tuple of objects. The returned <code>args</code> are passed to <code>f</code> and <code>on_done</code>. This function is executed once per worker at the beggining.</li>
<li><strong><code>on_done = None</code></strong> : a function with signature <code>on_done(stage_status, *args)</code>, where <code>args</code> is the return of <code>on_start</code> if present, else the signature is just <code>on_done(stage_status)</code>, and <code>stage_status</code> is of type <a href="#pypeln.process.StageStatus"><code>StageStatus</code></a>. This function is executed once per worker when the worker is done.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>stage</code> parameters is given then this function returns a new stage, else it returns a <code>Partial</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.map', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_start</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_done</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stage that maps a function `f` over the data. Its intended to behave like python&#39;s built-in `map` function but with the added concurrency.</span>

<span class="sd">        from pypeln import process as pr</span>
<span class="sd">        import time</span>
<span class="sd">        from random import random</span>

<span class="sd">        def slow_add1(x):</span>
<span class="sd">            time.sleep(random()) # &lt;= some slow computation</span>
<span class="sd">            return x + 1</span>

<span class="sd">        data = range(10) # [0, 1, 2, ..., 9]</span>
<span class="sd">        stage = pr.map(slow_add1, data, workers = 3, maxsize = 4)</span>

<span class="sd">        data = list(stage) # e.g. [2, 1, 5, 6, 3, 4, 7, 8, 9, 10]</span>

<span class="sd">    Note that because of concurrency order is not guaranteed.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`f`** : a function with signature `f(x, *args) -&gt; y`, where `args` is the return of `on_start` if present, else the signature is just `f(x) -&gt; y`. </span>
<span class="sd">    * **`stage = Undefined`** : a stage or iterable.</span>
<span class="sd">    * **`workers = 1`** : the number of workers the stage should contain.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>
<span class="sd">    * **`on_start = None`** : a function with signature `on_start() -&gt; args`, where `args` can be any object different than `None` or a tuple of objects. The returned `args` are passed to `f` and `on_done`. This function is executed once per worker at the beggining.</span>
<span class="sd">    * **`on_done = None`** : a function with signature `on_done(stage_status, *args)`, where `args` is the return of `on_start` if present, else the signature is just `on_done(stage_status)`, and `stage_status` is of type `pypeln.process.StageStatus`. This function is executed once per worker when the worker is done.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns a new stage, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">on_start</span><span class="o">=</span><span class="n">on_start</span><span class="p">,</span> <span class="n">on_done</span><span class="o">=</span><span class="n">on_done</span><span class="p">))</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">_to_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_Stage</span><span class="p">(</span>
        <span class="n">worker_constructor</span> <span class="o">=</span> <span class="n">WORKER</span><span class="p">,</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="n">workers</span><span class="p">,</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">,</span>
        <span class="n">on_start</span> <span class="o">=</span> <span class="n">on_start</span><span class="p">,</span>
        <span class="n">on_done</span> <span class="o">=</span> <span class="n">on_done</span><span class="p">,</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_map</span><span class="p">,</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,),</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">stage</span><span class="p">],</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.run">
    <p>def <span class="ident">run</span>(</p><p>stages, maxsize=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterates over one or more stages until their iterators run out of elements.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">pypeln</span> <span class="kn">import</span> <span class="n">process</span> <span class="k">as</span> <span class="n">pr</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">()</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">slow_fn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">workers</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span>

<span class="c1"># execute pipeline</span>
<span class="n">pr</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
</pre></div>


<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>stages</code></strong> : a stage/iterable or list of stages/iterables to be iterated over. If a list is passed, stages are first merged using <a href="#pypeln.process.concat"><code>concat</code></a> before iterating.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li><code>None</code></li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.run', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.run" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterates over one or more stages until their iterators run out of elements.</span>

<span class="sd">        from pypeln import process as pr</span>

<span class="sd">        data = get_data()</span>
<span class="sd">        stage = pr.each(slow_fn, data, workers = 6)</span>

<span class="sd">        # execute pipeline</span>
<span class="sd">        pr.run(stage)</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stages`** : a stage/iterable or list of stages/iterables to be iterated over. If a list is passed, stages are first merged using `pypeln.process.concat` before iterating.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * `None`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected at least 1 stage to run&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">stages</span>

    <span class="n">stage</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pypeln.process.to_iterable">
    <p>def <span class="ident">to_iterable</span>(</p><p>stage=Undefined, maxsize=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates an iterable from a stage. This function is used by the stage's <code>__iter__</code> method with the default arguments.</p>
<h1><strong>Args</strong></h1>
<ul>
<li><strong><code>stage</code></strong> : a stage object.</li>
<li><strong><code>maxsize = 0</code></strong> : the maximum number of objects the stage can hold simultaneously, if set to <code>0</code> (default) then the stage can grow unbounded.</li>
</ul>
<h1><strong>Returns</strong></h1>
<ul>
<li>If the <code>stage</code> parameters is given then this function returns an iterable, else it returns a <code>Partial</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.to_iterable', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.to_iterable" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_iterable</span><span class="p">(</span><span class="n">stage</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span> <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an iterable from a stage. This function is used by the stage&#39;s `__iter__` method with the default arguments.</span>

<span class="sd">    # **Args**</span>
<span class="sd">    * **`stage`** : a stage object.</span>
<span class="sd">    * **`maxsize = 0`** : the maximum number of objects the stage can hold simultaneously, if set to `0` (default) then the stage can grow unbounded.</span>

<span class="sd">    # **Returns**</span>
<span class="sd">    * If the `stage` parameters is given then this function returns an iterable, else it returns a `Partial`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_undefined</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">Partial</span><span class="p">(</span><span class="k">lambda</span> <span class="n">stage</span><span class="p">:</span> <span class="n">_to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_iterable</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pypeln.process.StageStatus" class="name">class <span class="ident">StageStatus</span></p>
      
  
    <div class="desc"><p>Object passed to various <code>on_done</code> callbacks. It contains information about the stage in case book keeping is needed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.StageStatus', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.StageStatus" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">StageStatus</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object passed to various `on_done` callbacks. It contains information about the stage in case book keeping is needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">lock</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `bool` : `True` if all workers finished. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span><span class="o">.</span><span class="n">active_workers</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">active_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `int` : Number of active workers. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span><span class="o">.</span><span class="n">active_workers</span>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;StageStatus(done = {done}, active_workers = {active_workers})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">,</span>
            <span class="n">active_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_workers</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pypeln.process.StageStatus">StageStatus</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pypeln.process.StageStatus.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, namespace, lock)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pypeln.process.StageStatus.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pypeln.process.StageStatus.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="n">namespace</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">lock</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pypeln.process.StageStatus.active_workers" class="name">var <span class="ident">active_workers</span></p>
            

            
  
    <div class="desc"><p><code>int</code> : Number of active workers.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pypeln.process.StageStatus.done" class="name">var <span class="ident">done</span></p>
            

            
  
    <div class="desc"><p><code>bool</code> : <code>True</code> if all workers finished.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pypeln.process.WorkerInfo" class="name">class <span class="ident">WorkerInfo</span></p>
      
  
    <div class="desc"><p>WorkerInfo(index,)</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pypeln.process.WorkerInfo">WorkerInfo</a></li>
          <li>builtins.tuple</li>
          <li>builtins.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pypeln.process.WorkerInfo.index" class="name">var <span class="ident">index</span></p>
            

            
  
    <div class="desc"><p>Alias for field number 0</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
